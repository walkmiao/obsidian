/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

class StatusBar {
    constructor(statusBarEl) {
        this.messages = [];
        this.statusBarEl = statusBarEl;
    }
    displayMessage(message, timeout, forcing = false) {
        if (this.messages[0] && this.messages[0].message === message) {
            // don't show the same message twice
            return;
        }
        this.messages.push({
            message: `希果壳五彩: ${message.slice(0, 100)}`,
            timeout: timeout * 1000,
        });
        if (forcing) {
            this.currentMessage = null;
            this.lastMessageTimestamp = null;
            this.statusBarEl.setText('');
        }
        this.display();
    }
    display() {
        if (this.currentMessage) {
            let messageAge = Date.now() - this.lastMessageTimestamp;
            if (messageAge >= this.currentMessage.timeout) {
                this.currentMessage = null;
                this.lastMessageTimestamp = null;
            }
        }
        else if (this.messages.length) {
            this.currentMessage = this.messages.shift();
            this.statusBarEl.setText(this.currentMessage.message);
            this.lastMessageTimestamp = Date.now();
            return;
        }
        else {
            this.statusBarEl.setText('');
        }
    }
}

class BGCONSTS {
}
BGCONSTS.APPID = '30';
BGCONSTS.MARKET_INFO = 'obsidian-plugin';
BGCONSTS.ENDPOINT = 'obsidianwucai';
BGCONSTS.PRINT_LOG = false;
BGCONSTS.VERSION = '23.3.24';
BGCONSTS.VERSION_NUM = 230323;
BGCONSTS.SERVICE_ID = 7;
BGCONSTS.IS_DEBUG = false;

// the process.env variable will be replaced by its target value in the output main.js file
// const baseURL = 'http://localhost:22021' || 'https://marker.dotalk.cn'
const baseURL = process.env.WUCAI_SERVER_URL || 'https://marker.dotalk.cn';
const WAITING_STATUSES = ['PENDING', 'RECEIVED', 'STARTED', 'RETRY'];
const SUCCESS_STATUSES = ['SYNCING'];
const API_URL_INIT = '/apix/openapi/wucai/sync/init';
const API_URL_DOWNLOAD = '/apix/openapi/wucai/sync/download';
// define our initial settings
const DEFAULT_SETTINGS = {
    token: '',
    wuCaiDir: 'WuCai',
    frequency: '0',
    triggerOnLoad: true,
    isSyncing: false,
    lastSyncFailed: false,
    refreshNotes: false,
    notesToRefresh: [],
    notesPathIdsMap: {},
    notesIdsPathMap: {},
    reimportShowConfirmation: true,
    lastCursor: {
        lastId: 0,
        lastHighlightPKID: 0,
        lastTime: 0,
    },
};
// const localizeData = {
//   /**
//    * Run sync
//    * Synced
//    * Run sync
//    * Exporting WuCai data
//    * Building export...
//    * sync service expried
//    * Sync failed
//    * need advanced permission
//    */
//   CN: {
//     'call api failed': '',
//     "Can't connect to server": '',
//   },
// }
function logger(msg) {
    BGCONSTS.PRINT_LOG && console.log(msg);
}
function localize(msg) {
    return msg;
}
class WuCaiPlugin extends obsidian.Plugin {
    constructor() {
        super(...arguments);
        this.scheduleInterval = null;
    }
    checkResponseBody(buttonContext, rsp) {
        if (!rsp) {
            return false;
        }
        if (rsp && 1 === rsp.code) {
            return false;
        }
        let errCode = rsp.code;
        if (10000 === errCode) {
            // 无效的 Token ，需要重新生成
            this.settings.token = '';
        }
        else if (10100 === errCode || 10101 === errCode) {
            // 同步服务到期了
            this.settings.token = '';
        }
        let err = localize(rsp['message'] || 'call api failed');
        if (errCode) {
            err += ', error:' + errCode;
        }
        this.handleSyncError(buttonContext, err);
        return true;
    }
    getErrorMessageFromResponse(response) {
        if (response && response.status === 409) {
            return 'Sync in progress initiated by different client';
        }
        if (response && response.status === 417) {
            return 'Obsidian export is locked. Wait for an hour.';
        }
        return `${response ? response.statusText : "Can't connect to server"}`;
    }
    handleSyncError(buttonContext, msg) {
        this.clearSettingsAfterRun();
        this.settings.lastSyncFailed = true;
        this.saveSettings();
        if (buttonContext) {
            this.showInfoStatus(buttonContext.buttonEl.parentElement, msg, 'wc-error');
            buttonContext.buttonEl.setText(localize('Run sync'));
        }
        else {
            this.notice(msg, true, 4, true);
        }
    }
    clearSettingsAfterRun() {
        this.settings.isSyncing = false;
    }
    handleSyncSuccess(buttonContext, msg = 'Synced', lastCursor = null) {
        this.clearSettingsAfterRun();
        this.settings.lastSyncFailed = false;
        if (lastCursor) {
            let tmpCursor = this.getNewLastCursor(lastCursor, this.settings.lastCursor);
            if (tmpCursor) {
                this.settings.lastCursor = tmpCursor;
            }
        }
        this.saveSettings();
        // if we have a button context, update the text on it
        // this is the case if we fired on a "Run sync" click (the button)
        if (buttonContext) {
            this.showInfoStatus(buttonContext.buttonEl.parentNode.parentElement, msg, 'wc-success');
            buttonContext.buttonEl.setText('Run sync');
        }
    }
    callApi(url, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const reqtime = Math.floor(+new Date() / 1000);
            params['v'] = BGCONSTS.VERSION_NUM;
            params['serviceId'] = BGCONSTS.SERVICE_ID;
            url += `?appid=${BGCONSTS.APPID}&ep=${BGCONSTS.ENDPOINT}&version=${BGCONSTS.VERSION}&reqtime=${reqtime}`;
            return fetch(baseURL + url, {
                headers: Object.assign(Object.assign({}, this.getAuthHeaders()), { 'Content-Type': 'application/json' }),
                method: 'POST',
                body: JSON.stringify(params),
            });
        });
    }
    // 初始化同步
    exportInit(buttonContext, auto, flagx = '') {
        return __awaiter(this, void 0, void 0, function* () {
            const dirInfo = this.app.vault.getAbstractFileByPath(this.settings.wuCaiDir);
            const noteDirDeleted = !dirInfo || !(dirInfo instanceof obsidian.TFolder);
            // logger([
            //   'export init',
            //   this.settings.wuCaiDir,
            //   dirInfo,
            //   {
            //     noteDirDeleted,
            //     isFolder: dirInfo instanceof TFolder,
            //     isFile: dirInfo instanceof TFile,
            //   },
            // ])
            if (noteDirDeleted) {
                // 如果文件夹被删除，代表是重新同步
                this.settings.lastCursor = {
                    lastHighlightPKID: 0,
                    lastId: 0,
                    lastTime: 0,
                };
                this.settings.notesIdsPathMap = {};
                this.settings.notesPathIdsMap = {};
                this.settings.notesToRefresh = [];
                logger(['onload last cursor, deleted,', this.settings.lastCursor]);
            }
            else {
                logger(['onload last cursor, json, ', this.settings.lastCursor]);
            }
            let lastCursor = this.settings.lastCursor;
            let params = { noteDirDeleted, auto: auto && true, lastCursor };
            let rsp;
            try {
                rsp = yield this.callApi(API_URL_INIT, params);
            }
            catch (e) {
                logger(['WuCai Official plugin: fetch failed in exportInit: ', e]);
            }
            if (!rsp || !rsp.ok) {
                logger(['WuCai Official plugin: bad response in exportInit: ', rsp]);
                this.handleSyncError(buttonContext, this.getErrorMessageFromResponse(rsp));
                return;
            }
            let data2 = yield rsp.json();
            if (this.checkResponseBody(buttonContext, data2)) {
                return;
            }
            let data = data2['data'] || {};
            // logger(['in exportInit', data, this.settings.lastCursor])
            // 通过服务端计算来确定当前需要从哪个id开始同步笔记
            let tmpCursor = this.getNewLastCursor(data.lastCursor, this.settings.lastCursor);
            if (tmpCursor) {
                this.settings.lastCursor = tmpCursor;
                yield this.saveSettings();
            }
            if ('SYNCED' === data.taskStatus) {
                this.handleSyncSuccess(buttonContext, 'Synced', this.settings.lastCursor);
                let msg = 'Latest WuCai sync already happened on your other device. Data should be up to date';
                this.notice(msg, false, 4, true);
            }
            else if ('EXPIRED' == data.taskStatus) {
                this.handleSyncError(buttonContext, 'sync service expried');
            }
            else if (WAITING_STATUSES.includes(data.taskStatus)) {
                if (data.notesExported > 0) {
                    const progressMsg = localize('Exporting WuCai data') + ` (${data.notesExported} / ${data.totalNotes}) ...`;
                    this.notice(progressMsg);
                }
                else {
                    this.notice('Building export...');
                }
                // re-try in 3 second
                yield new Promise((resolve) => setTimeout(resolve, 3000));
                yield this.exportInit(buttonContext, false, 'exportInit timeout');
            }
            else if (SUCCESS_STATUSES.includes(data.taskStatus)) {
                this.notice('Syncing WuCai data');
                return this.downloadArchive(this.settings.lastCursor, [], buttonContext, false, flagx || 'init');
            }
            else {
                this.handleSyncError(buttonContext, 'Sync failed,' + data.taskStatus);
            }
        });
    }
    notice(msg, show = false, timeout = 0, forcing = false) {
        if (show) {
            new obsidian.Notice(msg);
        }
        // @ts-ignore
        if (!obsidian.Platform.isMobileApp) {
            this.statusBar.displayMessage(msg.toLowerCase(), timeout, forcing);
        }
        else if (!show) {
            new obsidian.Notice(msg);
        }
    }
    showInfoStatus(container, msg, className = '') {
        let info = container.find('.wc-info-container');
        if (info) {
            info.setText(msg);
            info.addClass(className);
        }
    }
    clearInfoStatus(container) {
        let info = container.find('.wc-info-container');
        info.empty();
    }
    getAuthHeaders() {
        return {
            AUTHORIZATION: `Token ${this.settings.token}`,
            'Obsidian-Client': `${this.getObsidianClientID()}`,
        };
    }
    // 是否有对应的本地名称（出现这样的情况是本地做了重命名或移动文件夹)
    findLocalFileNameByNoteId(noteID) {
        let note = this.settings.notesIdsPathMap[noteID];
        if (!note || note == undefined) {
            return '';
        }
        let newfn = note.path;
        if (newfn.startsWith(this.settings.wuCaiDir + '/')) {
            // 只有在指定的文件夹内移动才会保持关联
            return newfn;
        }
        return '';
    }
    getNewLastCursor(lc, savedCusor) {
        if (!lc) {
            return;
        }
        savedCusor = savedCusor || { lastId: 0, lastHighlightPKID: 0, lastTime: 0 };
        let lastId = savedCusor.lastId || 0;
        let lastHighlightPKID = savedCusor.lastHighlightPKID || 0;
        let lastTime = savedCusor.lastTime || 0;
        // 同步点位必须有一项是向前移动的
        if (lc.lastId <= lastId && lc.lastHighlightPKID <= lastHighlightPKID && lc.lastTime <= lastTime) {
            return;
        }
        return {
            lastId: lc.lastId > lastId ? lc.lastId : lastId,
            lastHighlightPKID: lc.lastHighlightPKID > lastHighlightPKID ? lc.lastHighlightPKID : lastHighlightPKID,
            lastTime: lc.lastTime > lastTime ? lc.lastTime : lastTime,
        };
    }
    // 指定范围或指定笔记进行同步
    downloadArchive(lastCursor, noteIds, buttonContext, isOverwrite, flagx = '') {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            try {
                // 同步范围: lastCursor, or noteIds
                response = yield this.callApi(API_URL_DOWNLOAD, { lastCursor, noteIds, flagx });
            }
            catch (e) {
                logger(['WuCai Official plugin: fetch failed in downloadArchive: ', e]);
            }
            if (!response || !response.ok) {
                logger(['WuCai Official plugin: bad response in downloadArchive: ', response]);
                this.handleSyncError(buttonContext, this.getErrorMessageFromResponse(response));
                return;
            }
            // let blob = await response.blob()
            let data2 = yield response.json();
            if (this.checkResponseBody(buttonContext, data2)) {
                return;
            }
            let entries = data2['data']['entries'] || [];
            // const blobReader = new zip.BlobReader(blob)
            // const zipReader = new zip.ZipReader(blobReader)
            // const entries = await zipReader.getEntries()
            // 不用提示了
            // this.notice('Saving files...', false, 30)
            // 是否为定向同步
            const isPartsDownloadLogic = noteIds.length > 0;
            let entriesCount = entries.length;
            // 保存同步过来的文件
            for (const entry of entries) {
                let noteId;
                const processedFileName = obsidian.normalizePath(entry.filename.replace(/^WuCai/, this.settings.wuCaiDir));
                try {
                    // const contents = await entry.getData(new zip.TextWriter())
                    const contents = entry.contents;
                    noteId = '' + entry.noteId;
                    // 计算出笔记的最终路径和名字
                    let originalName = this.findLocalFileNameByNoteId(noteId) || processedFileName;
                    originalName = originalName.replace(/\/*$/, '');
                    logger(['sync note', originalName, processedFileName]);
                    let dirPath = originalName.substring(0, originalName.lastIndexOf('/'));
                    const fileInfo = yield this.app.vault.getAbstractFileByPath(dirPath);
                    if (!fileInfo || !(fileInfo instanceof obsidian.TFolder)) {
                        yield this.app.vault.createFolder(dirPath);
                    }
                    this.settings.notesPathIdsMap[originalName] = noteId;
                    this.settings.notesIdsPathMap[noteId] = { path: originalName, updateAt: entry.updateAt };
                    const originalFile = yield this.app.vault.getAbstractFileByPath(originalName);
                    if (!originalFile || !(originalFile instanceof obsidian.TFile)) {
                        yield this.app.vault.create(originalName, contents);
                    }
                    else {
                        // if (isOverwrite) {
                        //   await this.app.vault.modify(originalFile, contents)
                        // } else {
                        //   // 如果本地文件已经存在，且不允许覆盖的时候，追加新的内容到文件末尾
                        //   const oldCnt = await this.app.vault.read(originalFile)
                        //   if (oldCnt !== contents) {
                        //     await this.app.vault.append(originalFile, '\n' + contents)
                        //   }
                        // }
                        yield this.app.vault.modify(originalFile, contents);
                    }
                }
                catch (e) {
                    logger([`WuCai Official plugin: error writing ${processedFileName}:`, e]);
                    this.notice(`WuCai: error while writing ${processedFileName}: ${e}`, true, 4, true);
                    if (noteId) {
                        this.settings.notesToRefresh.push(noteId);
                        yield this.saveSettings();
                    }
                }
            }
            let isCompleted = false;
            if (isPartsDownloadLogic) {
                // 当前是指定笔记进行同步，所以每次就代表是一组同步完成
                isCompleted = true;
            }
            else {
                // 计算同步后的位置
                // 在同步的过程中不断的更新同步位置
                // 不是定向同步时，记录同步位置
                let notesLastCursor = data2['data'].lastCursor;
                let tmpCursor = this.getNewLastCursor(notesLastCursor, lastCursor);
                if (tmpCursor) {
                    this.settings.lastCursor = tmpCursor;
                    // 当前是通过偏移量范围进行同步
                    isCompleted = entriesCount <= 0;
                }
                else {
                    // 因为某种原因导致的定位不准，结束同步
                    isCompleted = true;
                }
            }
            yield this.saveSettings();
            // close the ZipReader
            // await zipReader.close()
            if (isCompleted) {
                yield this.acknowledgeSyncCompleted(buttonContext);
                this.handleSyncSuccess(buttonContext, 'Synced!', this.settings.lastCursor);
                this.notice('WuCai sync completed', true, 1, true);
                // @ts-ignore
                if (obsidian.Platform.isMobileApp) {
                    this.notice("If you don't see all of your WuCai files reload obsidian app", true);
                }
            }
            else if (BGCONSTS.IS_DEBUG) {
                yield this.acknowledgeSyncCompleted(buttonContext);
                this.handleSyncSuccess(buttonContext, 'Synced! debug mode', this.settings.lastCursor);
                this.notice('WuCai sync completed, in debug mode', true, 1, true);
            }
            else if (!BGCONSTS.IS_DEBUG) {
                this.handleSyncSuccess(buttonContext, 'syncing', this.settings.lastCursor);
                // this.notice('WuCai is syncing, ' + exportID, true, 1, true)
                yield new Promise((resolve) => setTimeout(resolve, 5000));
                this.downloadArchive(this.settings.lastCursor, [], buttonContext, isOverwrite);
            }
        });
    }
    acknowledgeSyncCompleted(buttonContext) {
        return __awaiter(this, void 0, void 0, function* () {
            let rsp;
            let url = '/apix/openapi/wucai/sync/ack';
            try {
                let params = { lastCursor: this.settings.lastCursor };
                rsp = yield this.callApi(url, params);
            }
            catch (e) {
                logger(['WuCai Official plugin: fetch failed to acknowledged sync: ', e]);
            }
            if (rsp && !rsp.ok) {
                logger(['WuCai Official plugin: bad response in acknowledge sync: ', rsp]);
                this.handleSyncError(buttonContext, this.getErrorMessageFromResponse(rsp));
            }
        });
    }
    configureSchedule() {
        return __awaiter(this, void 0, void 0, function* () {
            const minutes = parseInt(this.settings.frequency);
            let milliseconds = minutes * 60 * 1000; // minutes * seconds * milliseconds
            logger(['WuCai Official plugin: setting interval to ', minutes, 'minutes']);
            window.clearInterval(this.scheduleInterval);
            this.scheduleInterval = null;
            if (!milliseconds) {
                // we got manual option
                return;
            }
            this.scheduleInterval = window.setInterval(() => this.exportInit(null, true, 'schedule init'), milliseconds);
            this.registerInterval(this.scheduleInterval);
        });
    }
    refreshNoteExport() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.settings.refreshNotes) {
                return;
            }
            let noteIds = this.settings.notesToRefresh || [];
            if (noteIds.length <= 0) {
                return;
            }
            let newNoteIds = [];
            for (let i = 0; i < noteIds.length; i++) {
                newNoteIds.push(parseInt(noteIds[i]));
                if (i >= 5) {
                    break;
                }
            }
            this.downloadArchive(null, newNoteIds, null, true, 'refresh');
            this.settings.notesToRefresh = this.settings.notesToRefresh.filter((n) => !newNoteIds.includes(parseInt(n)));
        });
    }
    addNoteToRefresh(noteId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings.notesToRefresh.push(noteId);
            yield this.saveSettings();
        });
    }
    reimportFile(vault, fileName, isOverwrite = false) {
        const noteId = this.settings.notesPathIdsMap[fileName];
        if (!noteId) {
            this.notice('Failed to reimport. note id not found', true);
            return;
        }
        this.downloadArchive(null, [parseInt(noteId)], null, isOverwrite);
    }
    startSync() {
        logger(['started sync', this.settings.isSyncing]);
        if (this.settings.isSyncing) {
            this.notice('WuCai sync already in progress', true);
        }
        else {
            this.settings.isSyncing = true;
            this.saveSettings();
            this.exportInit(null, false, 'startSync init');
        }
    }
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore
            if (!obsidian.Platform.isMobileApp) {
                this.statusBar = new StatusBar(this.addStatusBarItem());
                this.registerInterval(window.setInterval(() => this.statusBar.display(), 1000));
            }
            yield this.loadSettings();
            this.registerEvent(this.app.vault.on('delete', (file) => __awaiter(this, void 0, void 0, function* () {
                // 将删除的文件放到待更新列表，这样下次就可以重新同步删除的问题
                const noteID = this.settings.notesPathIdsMap[file.path];
                if (noteID) {
                    yield this.addNoteToRefresh(noteID);
                }
                delete this.settings.notesPathIdsMap[file.path];
                delete this.settings.notesIdsPathMap[noteID];
                this.saveSettings();
                if (noteID) {
                    this.refreshNoteExport();
                }
            })));
            this.registerEvent(this.app.vault.on('rename', (file, oldPath) => {
                // 如果是五彩划线目录里的文件，在重命名的时候，进行关联，以保证下次同步能找到相应的文件
                if (!oldPath.startsWith(this.settings.wuCaiDir + '/')) {
                    return;
                }
                logger(['rename path', file, oldPath]);
                const noteID = this.settings.notesPathIdsMap[oldPath];
                if (!noteID) {
                    // 检测是否是修改的目录，如果是目录，则需要更新目录下的所有映射关系
                    let oldPathLength = oldPath.length;
                    for (let tmpNoteId in this.settings.notesIdsPathMap) {
                        let note = this.settings.notesIdsPathMap[tmpNoteId];
                        if (!note || note == undefined) {
                            continue;
                        }
                        let tmpOldPath = note.path;
                        if (tmpOldPath.startsWith(oldPath + '/')) {
                            // 更新此文件夹下面的文件映射关系
                            let tmpNewPath = file.path + tmpOldPath.substring(oldPathLength);
                            logger(['rename map, ', oldPath, tmpOldPath, tmpNewPath]);
                            delete this.settings.notesPathIdsMap[tmpOldPath];
                            this.settings.notesPathIdsMap[tmpNewPath] = tmpNoteId;
                            this.settings.notesIdsPathMap[tmpNoteId].path = tmpNewPath;
                        }
                    }
                    return;
                }
                this.settings.notesPathIdsMap[file.path] = noteID;
                this.settings.notesIdsPathMap[noteID].path = file.path;
                delete this.settings.notesPathIdsMap[oldPath];
                this.saveSettings();
            }));
            this.addCommand({
                id: 'sync',
                name: 'Sync your data now',
                callback: () => {
                    this.startSync();
                },
            });
            // this.addCommand({
            //   id: 'wucai-official-format',
            //   name: 'Customize formatting',
            //   callback: () => window.open(`${baseURL}/export/obsidian/preferences`),
            // })
            this.addCommand({
                id: 'reimport',
                name: 'Delete and reimport this document',
                editorCheckCallback: (checking, editor, view) => {
                    const activeFilePath = view.file.path;
                    const isRWfile = activeFilePath in this.settings.notesPathIdsMap;
                    if (checking) {
                        return isRWfile;
                    }
                    if (this.settings.reimportShowConfirmation) {
                        const modal = new obsidian.Modal(view.app);
                        modal.contentEl.createEl('p', {
                            text: 'Warning: Proceeding will delete this file entirely (including any changes you made) ' +
                                'and then reimport a new copy of your highlights from WuCai.',
                        });
                        const buttonsContainer = modal.contentEl.createEl('div', { cls: 'wc-modal-btns' });
                        const cancelBtn = buttonsContainer.createEl('button', { text: 'Cancel' });
                        const confirmBtn = buttonsContainer.createEl('button', { text: 'Proceed', cls: 'mod-warning' });
                        const showConfContainer = modal.contentEl.createEl('div', { cls: 'wc-modal-confirmation' });
                        showConfContainer.createEl('label', { attr: { for: 'wc-ask-nl' }, text: "on't ask me in the future" });
                        const showConf = showConfContainer.createEl('input', { type: 'checkbox', attr: { name: 'wc-ask-nl' } });
                        showConf.addEventListener('change', (ev) => {
                            // @ts-ignore
                            this.settings.reimportShowConfirmation = !ev.target.checked;
                            this.saveSettings();
                        });
                        cancelBtn.onClickEvent(() => {
                            modal.close();
                        });
                        confirmBtn.onClickEvent(() => {
                            this.reimportFile(view.app.vault, activeFilePath, true);
                            modal.close();
                        });
                        modal.open();
                    }
                    else {
                        this.reimportFile(view.app.vault, activeFilePath, true);
                    }
                },
            });
            // this.registerMarkdownPostProcessor((el, ctx) => {
            //   if (!ctx.sourcePath.startsWith(this.settings.wuCaiDir)) {
            //     return
            //   }
            //   let matches: string[]
            //   try {
            //     // @ts-ignore
            //     matches = [...ctx.getSectionInfo(el).text.matchAll(/__(.+)__/g)].map((a) => a[1])
            //   } catch (TypeError) {
            //     // failed interaction with a Dataview element
            //     return
            //   }
            //   const hypers = el.findAll('strong').filter((e) => matches.contains(e.textContent))
            //   hypers.forEach((strongEl) => {
            //     const replacement = el.createEl('span')
            //     while (strongEl.firstChild) {
            //       replacement.appendChild(strongEl.firstChild)
            //     }
            //     replacement.addClass('wc-hyper-highlight')
            //     strongEl.replaceWith(replacement)
            //   })
            // })
            this.addSettingTab(new WuCaiSettingTab(this.app, this));
            yield this.configureSchedule();
            this.settings.isSyncing = false;
            if (this.settings.token && this.settings.triggerOnLoad && !this.settings.isSyncing) {
                // 因为加载关系，如果目录没有创建，可能是ob还没有启动完成
                const dirInfo = this.app.vault.getAbstractFileByPath(this.settings.wuCaiDir);
                const noteDirNotExists = !dirInfo || !(dirInfo instanceof obsidian.TFolder);
                if (noteDirNotExists) {
                    this.app.workspace.onLayoutReady(() => {
                        // https://forum.obsidian.md/t/plugins-with-a-lot-to-do-at-startup-being-async-onlayoutready/26205
                        logger(['onload last cursor 1', this.settings.lastCursor]);
                        this.exportInit(null, true, 'onload + not exists');
                    });
                }
                else {
                    yield this.refreshNoteExport();
                    logger(['onload last cursor 2', this.settings.lastCursor]);
                    yield this.exportInit(null, true, 'onload + exists');
                }
            }
        });
    }
    onunload() {
        // 暂时没有逻辑需要处理
        return;
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
    getObsidianClientID() {
        let tmpId = window.localStorage.getItem('wc-ObsidianClientId');
        if (tmpId) {
            return tmpId;
        }
        tmpId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        window.localStorage.setItem('wc-ObsidianClientId', tmpId);
        return tmpId;
    }
    getUserAuthToken(button, attempt = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            let uuid = this.getObsidianClientID();
            if (attempt === 0) {
                window.open(`${baseURL}/page/gentoken/${BGCONSTS.SERVICE_ID}/${uuid}`);
            }
            let response;
            try {
                let url = '/page/auth/openapi/gettoken';
                response = yield this.callApi(url, { did: uuid });
            }
            catch (e) {
                logger(['WuCai Official plugin: fetch failed in getUserAuthToken: ', e]);
            }
            if (!response || !response.ok) {
                logger(['WuCai Official plugin: bad response in getUserAuthToken: ', response]);
                this.showInfoStatus(button.parentElement, 'Authorization failed. Try again', 'wc-error');
                return;
            }
            let data2 = yield response.json();
            let data;
            data = data2['data'];
            if (1 === data2.code && data.accessToken) {
                this.settings.token = data.accessToken;
            }
            else {
                if (attempt > 20) {
                    logger('WuCai Official plugin: reached attempt limit in getUserAuthToken');
                    return;
                }
                logger(`WuCai Official plugin: didn't get token data, retrying (attempt ${attempt + 1})`);
                yield new Promise((resolve) => setTimeout(resolve, 1000));
                yield this.getUserAuthToken(button, attempt + 1);
            }
            yield this.saveSettings();
            return true;
        });
    }
}
class WuCaiSettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    display() {
        let { containerEl } = this;
        containerEl.empty();
        containerEl.createEl('h1', { text: 'WuCai Highlights Official' });
        containerEl
            .createEl('p', { text: 'Created by ' })
            .createEl('a', { text: '希果壳五彩', href: 'https://www.dotalk.cn/product/wucai' });
        containerEl.getElementsByTagName('p')[0].appendText(' 🚀🚀');
        containerEl.createEl('h2', { text: 'Settings' });
        let token = this.plugin.settings.token;
        if (token && token.length > 0) {
            new obsidian.Setting(containerEl)
                .setName('Sync your WuCai data with Obsidian')
                .setDesc('On first sync, the WuCai plugin will create a new folder containing all your highlights')
                .setClass('wc-setting-sync')
                .addButton((button) => {
                button
                    .setCta()
                    .setTooltip('Once the sync begins, you can close this plugin page')
                    .setButtonText('Initiate Sync')
                    .onClick(() => __awaiter(this, void 0, void 0, function* () {
                    if (this.plugin.settings.isSyncing) {
                        // NOTE: This is used to prevent multiple syncs at the same time. However, if a previous sync fails,
                        //  it can stop new syncs from happening. Make sure to set isSyncing to false
                        //  if there's ever errors/failures in previous sync attempts, so that
                        //  we don't block syncing subsequent times.
                        new obsidian.Notice('WuCai sync already in progress');
                    }
                    else {
                        this.plugin.clearInfoStatus(containerEl);
                        this.plugin.settings.isSyncing = true;
                        yield this.plugin.saveData(this.plugin.settings);
                        button.setButtonText('Syncing...');
                        yield this.plugin.exportInit(button);
                    }
                }));
            });
            let el = containerEl.createEl('div', { cls: 'wc-info-container' });
            containerEl.find('.wc-setting-sync > .setting-item-control ').prepend(el);
            new obsidian.Setting(containerEl)
                .setName('Customize formatting options')
                .setDesc('You can customize which items export to Obsidian and how they appear from the WuCai website')
                .addButton((button) => {
                button.setButtonText('Customize').onClick(() => {
                    window.open(`${baseURL}/page/plugins/obsidian/preferences`);
                });
            });
            new obsidian.Setting(containerEl)
                .setName('Customize base folder')
                .setDesc('By default, the plugin will save all your highlights into a folder named WuCai')
                .addText((text) => text
                .setPlaceholder('Defaults to: WuCai')
                .setValue(this.plugin.settings.wuCaiDir)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.wuCaiDir = obsidian.normalizePath(value || 'WuCai');
                yield this.plugin.saveSettings();
            })));
            new obsidian.Setting(containerEl)
                .setName('Configure resync frequency')
                .setDesc('If not set to Manual, WuCai will automatically resync with Obsidian when the app is open at the specified interval')
                .addDropdown((dropdown) => {
                dropdown.addOption('0', 'Manual');
                dropdown.addOption('60', 'Every 1 hour');
                dropdown.addOption((12 * 60).toString(), 'Every 12 hours');
                dropdown.addOption((24 * 60).toString(), 'Every 24 hours');
                // select the currently-saved option
                dropdown.setValue(this.plugin.settings.frequency);
                dropdown.onChange((newValue) => {
                    // update the plugin settings
                    this.plugin.settings.frequency = newValue;
                    this.plugin.saveSettings();
                    // destroy & re-create the scheduled task
                    this.plugin.configureSchedule();
                });
            });
            new obsidian.Setting(containerEl)
                .setName('Sync automatically when Obsidian opens')
                .setDesc('If enabled, WuCai will automatically resync with Obsidian each time you open the app')
                .addToggle((toggle) => {
                toggle.setValue(this.plugin.settings.triggerOnLoad);
                toggle.onChange((val) => {
                    this.plugin.settings.triggerOnLoad = val;
                    this.plugin.saveSettings();
                });
            });
            new obsidian.Setting(containerEl)
                .setName('Resync deleted files')
                .setDesc('If enabled, you can refresh individual items by deleting the file in Obsidian and initiating a resync')
                .addToggle((toggle) => {
                toggle.setValue(this.plugin.settings.refreshNotes);
                toggle.onChange((val) => __awaiter(this, void 0, void 0, function* () {
                    this.plugin.settings.refreshNotes = val;
                    yield this.plugin.saveSettings();
                    if (val) {
                        this.plugin.refreshNoteExport();
                    }
                }));
            });
            if (this.plugin.settings.lastSyncFailed) {
                this.plugin.showInfoStatus(containerEl.find('.wc-setting-sync .wc-info-container').parentElement, 'Last sync failed', 'wc-error');
            }
        }
        else {
            // 没有配置 token 的情况
            new obsidian.Setting(containerEl)
                .setName('Connect Obsidian to WuCai')
                .setClass('wc-setting-connect')
                .setDesc('The WuCai plugin enables automatic syncing of all your highlights . Note: Requires WuCai account.')
                .addButton((button) => {
                button
                    .setButtonText('Connect')
                    .setCta()
                    .onClick((evt) => __awaiter(this, void 0, void 0, function* () {
                    const success = yield this.plugin.getUserAuthToken(evt.target);
                    if (success) {
                        this.display();
                    }
                }));
            });
            let el = containerEl.createEl('div', { cls: 'wc-info-container' });
            containerEl.find('.wc-setting-connect > .setting-item-control ').prepend(el);
        }
        const help = containerEl.createEl('p');
        help.innerHTML = "Question? Please see our <a href='https://www.dotalk.cn/s/M7'>feedback</a> 🙂";
    }
}

module.exports = WuCaiPlugin;
