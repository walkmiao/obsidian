/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

class StatusBar {
    constructor(statusBarEl) {
        this.messages = [];
        this.statusBarEl = statusBarEl;
    }
    displayMessage(message, timeout, forcing = false) {
        if (this.messages[0] && this.messages[0].message === message) {
            // don't show the same message twice
            return;
        }
        this.messages.push({
            message: `å¸Œæœå£³äº”å½©: ${message.slice(0, 100)}`,
            timeout: timeout * 1000,
        });
        if (forcing) {
            this.currentMessage = null;
            this.lastMessageTimestamp = null;
            this.statusBarEl.setText('');
        }
        this.display();
    }
    display() {
        if (this.currentMessage) {
            let messageAge = Date.now() - this.lastMessageTimestamp;
            if (messageAge >= this.currentMessage.timeout) {
                this.currentMessage = null;
                this.lastMessageTimestamp = null;
            }
        }
        else if (this.messages.length) {
            this.currentMessage = this.messages.shift();
            this.statusBarEl.setText(this.currentMessage.message);
            this.lastMessageTimestamp = Date.now();
            return;
        }
        else {
            this.statusBarEl.setText('');
        }
    }
}

class BGCONSTS {
}
BGCONSTS.APPID = '30';
BGCONSTS.MARKET_INFO = 'obsidian-plugin';
BGCONSTS.ENDPOINT = 'obsidianwucai';
BGCONSTS.PRINT_LOG = false;
BGCONSTS.VERSION = '23.3.24';
BGCONSTS.VERSION_NUM = 230323;
BGCONSTS.SERVICE_ID = 7;
BGCONSTS.IS_DEBUG = false;

// the process.env variable will be replaced by its target value in the output main.js file
// const baseURL = 'http://localhost:22021' || 'https://marker.dotalk.cn'
const baseURL = process.env.WUCAI_SERVER_URL || 'https://marker.dotalk.cn';
const WAITING_STATUSES = ['PENDING', 'RECEIVED', 'STARTED', 'RETRY'];
const SUCCESS_STATUSES = ['SYNCING'];
const API_URL_INIT = '/apix/openapi/wucai/sync/init';
const API_URL_DOWNLOAD = '/apix/openapi/wucai/sync/download';
// define our initial settings
const DEFAULT_SETTINGS = {
    token: '',
    wuCaiDir: 'WuCai',
    frequency: '0',
    triggerOnLoad: true,
    isSyncing: false,
    lastSyncFailed: false,
    refreshNotes: false,
    notesToRefresh: [],
    notesPathIdsMap: {},
    notesIdsPathMap: {},
    reimportShowConfirmation: true,
    lastCursor: {
        lastId: 0,
        lastHighlightPKID: 0,
        lastTime: 0,
    },
};
// const localizeData = {
//   /**
//    * Run sync
//    * Synced
//    * Run sync
//    * Exporting WuCai data
//    * Building export...
//    * sync service expried
//    * Sync failed
//    * need advanced permission
//    */
//   CN: {
//     'call api failed': '',
//     "Can't connect to server": '',
//   },
// }
function logger(msg) {
    BGCONSTS.PRINT_LOG && console.log(msg);
}
function localize(msg) {
    return msg;
}
class WuCaiPlugin extends obsidian.Plugin {
    constructor() {
        super(...arguments);
        this.scheduleInterval = null;
    }
    checkResponseBody(buttonContext, rsp) {
        if (!rsp) {
            return false;
        }
        if (rsp && 1 === rsp.code) {
            return false;
        }
        let errCode = rsp.code;
        if (10000 === errCode) {
            // æ— æ•ˆçš„ Token ï¼Œéœ€è¦é‡æ–°ç”Ÿæˆ
            this.settings.token = '';
        }
        else if (10100 === errCode || 10101 === errCode) {
            // åŒæ­¥æœåŠ¡åˆ°æœŸäº†
            this.settings.token = '';
        }
        let err = localize(rsp['message'] || 'call api failed');
        if (errCode) {
            err += ', error:' + errCode;
        }
        this.handleSyncError(buttonContext, err);
        return true;
    }
    getErrorMessageFromResponse(response) {
        if (response && response.status === 409) {
            return 'Sync in progress initiated by different client';
        }
        if (response && response.status === 417) {
            return 'Obsidian export is locked. Wait for an hour.';
        }
        return `${response ? response.statusText : "Can't connect to server"}`;
    }
    handleSyncError(buttonContext, msg) {
        this.clearSettingsAfterRun();
        this.settings.lastSyncFailed = true;
        this.saveSettings();
        if (buttonContext) {
            this.showInfoStatus(buttonContext.buttonEl.parentElement, msg, 'wc-error');
            buttonContext.buttonEl.setText(localize('Run sync'));
        }
        else {
            this.notice(msg, true, 4, true);
        }
    }
    clearSettingsAfterRun() {
        this.settings.isSyncing = false;
    }
    handleSyncSuccess(buttonContext, msg = 'Synced', lastCursor = null) {
        this.clearSettingsAfterRun();
        this.settings.lastSyncFailed = false;
        if (lastCursor) {
            let tmpCursor = this.getNewLastCursor(lastCursor, this.settings.lastCursor);
            if (tmpCursor) {
                this.settings.lastCursor = tmpCursor;
            }
        }
        this.saveSettings();
        // if we have a button context, update the text on it
        // this is the case if we fired on a "Run sync" click (the button)
        if (buttonContext) {
            this.showInfoStatus(buttonContext.buttonEl.parentNode.parentElement, msg, 'wc-success');
            buttonContext.buttonEl.setText('Run sync');
        }
    }
    callApi(url, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const reqtime = Math.floor(+new Date() / 1000);
            params['v'] = BGCONSTS.VERSION_NUM;
            params['serviceId'] = BGCONSTS.SERVICE_ID;
            url += `?appid=${BGCONSTS.APPID}&ep=${BGCONSTS.ENDPOINT}&version=${BGCONSTS.VERSION}&reqtime=${reqtime}`;
            return fetch(baseURL + url, {
                headers: Object.assign(Object.assign({}, this.getAuthHeaders()), { 'Content-Type': 'application/json' }),
                method: 'POST',
                body: JSON.stringify(params),
            });
        });
    }
    // åˆå§‹åŒ–åŒæ­¥
    exportInit(buttonContext, auto, flagx = '') {
        return __awaiter(this, void 0, void 0, function* () {
            const dirInfo = this.app.vault.getAbstractFileByPath(this.settings.wuCaiDir);
            const noteDirDeleted = !dirInfo || !(dirInfo instanceof obsidian.TFolder);
            // logger([
            //   'export init',
            //   this.settings.wuCaiDir,
            //   dirInfo,
            //   {
            //     noteDirDeleted,
            //     isFolder: dirInfo instanceof TFolder,
            //     isFile: dirInfo instanceof TFile,
            //   },
            // ])
            if (noteDirDeleted) {
                // å¦‚æœæ–‡ä»¶å¤¹è¢«åˆ é™¤ï¼Œä»£è¡¨æ˜¯é‡æ–°åŒæ­¥
                this.settings.lastCursor = {
                    lastHighlightPKID: 0,
                    lastId: 0,
                    lastTime: 0,
                };
                this.settings.notesIdsPathMap = {};
                this.settings.notesPathIdsMap = {};
                this.settings.notesToRefresh = [];
                logger(['onload last cursor, deleted,', this.settings.lastCursor]);
            }
            else {
                logger(['onload last cursor, json, ', this.settings.lastCursor]);
            }
            let lastCursor = this.settings.lastCursor;
            let params = { noteDirDeleted, auto: auto && true, lastCursor };
            let rsp;
            try {
                rsp = yield this.callApi(API_URL_INIT, params);
            }
            catch (e) {
                logger(['WuCai Official plugin: fetch failed in exportInit: ', e]);
            }
            if (!rsp || !rsp.ok) {
                logger(['WuCai Official plugin: bad response in exportInit: ', rsp]);
                this.handleSyncError(buttonContext, this.getErrorMessageFromResponse(rsp));
                return;
            }
            let data2 = yield rsp.json();
            if (this.checkResponseBody(buttonContext, data2)) {
                return;
            }
            let data = data2['data'] || {};
            // logger(['in exportInit', data, this.settings.lastCursor])
            // é€šè¿‡æœåŠ¡ç«¯è®¡ç®—æ¥ç¡®å®šå½“å‰éœ€è¦ä»å“ªä¸ªidå¼€å§‹åŒæ­¥ç¬”è®°
            let tmpCursor = this.getNewLastCursor(data.lastCursor, this.settings.lastCursor);
            if (tmpCursor) {
                this.settings.lastCursor = tmpCursor;
                yield this.saveSettings();
            }
            if ('SYNCED' === data.taskStatus) {
                this.handleSyncSuccess(buttonContext, 'Synced', this.settings.lastCursor);
                let msg = 'Latest WuCai sync already happened on your other device. Data should be up to date';
                this.notice(msg, false, 4, true);
            }
            else if ('EXPIRED' == data.taskStatus) {
                this.handleSyncError(buttonContext, 'sync service expried');
            }
            else if (WAITING_STATUSES.includes(data.taskStatus)) {
                if (data.notesExported > 0) {
                    const progressMsg = localize('Exporting WuCai data') + ` (${data.notesExported} / ${data.totalNotes}) ...`;
                    this.notice(progressMsg);
                }
                else {
                    this.notice('Building export...');
                }
                // re-try in 3 second
                yield new Promise((resolve) => setTimeout(resolve, 3000));
                yield this.exportInit(buttonContext, false, 'exportInit timeout');
            }
            else if (SUCCESS_STATUSES.includes(data.taskStatus)) {
                this.notice('Syncing WuCai data');
                return this.downloadArchive(this.settings.lastCursor, [], buttonContext, false, flagx || 'init');
            }
            else {
                this.handleSyncError(buttonContext, 'Sync failed,' + data.taskStatus);
            }
        });
    }
    notice(msg, show = false, timeout = 0, forcing = false) {
        if (show) {
            new obsidian.Notice(msg);
        }
        // @ts-ignore
        if (!obsidian.Platform.isMobileApp) {
            this.statusBar.displayMessage(msg.toLowerCase(), timeout, forcing);
        }
        else if (!show) {
            new obsidian.Notice(msg);
        }
    }
    showInfoStatus(container, msg, className = '') {
        let info = container.find('.wc-info-container');
        if (info) {
            info.setText(msg);
            info.addClass(className);
        }
    }
    clearInfoStatus(container) {
        let info = container.find('.wc-info-container');
        info.empty();
    }
    getAuthHeaders() {
        return {
            AUTHORIZATION: `Token ${this.settings.token}`,
            'Obsidian-Client': `${this.getObsidianClientID()}`,
        };
    }
    // æ˜¯å¦æœ‰å¯¹åº”çš„æœ¬åœ°åç§°ï¼ˆå‡ºç°è¿™æ ·çš„æƒ…å†µæ˜¯æœ¬åœ°åšäº†é‡å‘½åæˆ–ç§»åŠ¨æ–‡ä»¶å¤¹)
    findLocalFileNameByNoteId(noteID) {
        let note = this.settings.notesIdsPathMap[noteID];
        if (!note || note == undefined) {
            return '';
        }
        let newfn = note.path;
        if (newfn.startsWith(this.settings.wuCaiDir + '/')) {
            // åªæœ‰åœ¨æŒ‡å®šçš„æ–‡ä»¶å¤¹å†…ç§»åŠ¨æ‰ä¼šä¿æŒå…³è”
            return newfn;
        }
        return '';
    }
    getNewLastCursor(lc, savedCusor) {
        if (!lc) {
            return;
        }
        savedCusor = savedCusor || { lastId: 0, lastHighlightPKID: 0, lastTime: 0 };
        let lastId = savedCusor.lastId || 0;
        let lastHighlightPKID = savedCusor.lastHighlightPKID || 0;
        let lastTime = savedCusor.lastTime || 0;
        // åŒæ­¥ç‚¹ä½å¿…é¡»æœ‰ä¸€é¡¹æ˜¯å‘å‰ç§»åŠ¨çš„
        if (lc.lastId <= lastId && lc.lastHighlightPKID <= lastHighlightPKID && lc.lastTime <= lastTime) {
            return;
        }
        return {
            lastId: lc.lastId > lastId ? lc.lastId : lastId,
            lastHighlightPKID: lc.lastHighlightPKID > lastHighlightPKID ? lc.lastHighlightPKID : lastHighlightPKID,
            lastTime: lc.lastTime > lastTime ? lc.lastTime : lastTime,
        };
    }
    // æŒ‡å®šèŒƒå›´æˆ–æŒ‡å®šç¬”è®°è¿›è¡ŒåŒæ­¥
    downloadArchive(lastCursor, noteIds, buttonContext, isOverwrite, flagx = '') {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            try {
                // åŒæ­¥èŒƒå›´: lastCursor, or noteIds
                response = yield this.callApi(API_URL_DOWNLOAD, { lastCursor, noteIds, flagx });
            }
            catch (e) {
                logger(['WuCai Official plugin: fetch failed in downloadArchive: ', e]);
            }
            if (!response || !response.ok) {
                logger(['WuCai Official plugin: bad response in downloadArchive: ', response]);
                this.handleSyncError(buttonContext, this.getErrorMessageFromResponse(response));
                return;
            }
            // let blob = await response.blob()
            let data2 = yield response.json();
            if (this.checkResponseBody(buttonContext, data2)) {
                return;
            }
            let entries = data2['data']['entries'] || [];
            // const blobReader = new zip.BlobReader(blob)
            // const zipReader = new zip.ZipReader(blobReader)
            // const entries = await zipReader.getEntries()
            // ä¸ç”¨æç¤ºäº†
            // this.notice('Saving files...', false, 30)
            // æ˜¯å¦ä¸ºå®šå‘åŒæ­¥
            const isPartsDownloadLogic = noteIds.length > 0;
            let entriesCount = entries.length;
            // ä¿å­˜åŒæ­¥è¿‡æ¥çš„æ–‡ä»¶
            for (const entry of entries) {
                let noteId;
                const processedFileName = obsidian.normalizePath(entry.filename.replace(/^WuCai/, this.settings.wuCaiDir));
                try {
                    // const contents = await entry.getData(new zip.TextWriter())
                    const contents = entry.contents;
                    noteId = '' + entry.noteId;
                    // è®¡ç®—å‡ºç¬”è®°çš„æœ€ç»ˆè·¯å¾„å’Œåå­—
                    let originalName = this.findLocalFileNameByNoteId(noteId) || processedFileName;
                    originalName = originalName.replace(/\/*$/, '');
                    logger(['sync note', originalName, processedFileName]);
                    let dirPath = originalName.substring(0, originalName.lastIndexOf('/'));
                    const fileInfo = yield this.app.vault.getAbstractFileByPath(dirPath);
                    if (!fileInfo || !(fileInfo instanceof obsidian.TFolder)) {
                        yield this.app.vault.createFolder(dirPath);
                    }
                    this.settings.notesPathIdsMap[originalName] = noteId;
                    this.settings.notesIdsPathMap[noteId] = { path: originalName, updateAt: entry.updateAt };
                    const originalFile = yield this.app.vault.getAbstractFileByPath(originalName);
                    if (!originalFile || !(originalFile instanceof obsidian.TFile)) {
                        yield this.app.vault.create(originalName, contents);
                    }
                    else {
                        // if (isOverwrite) {
                        //   await this.app.vault.modify(originalFile, contents)
                        // } else {
                        //   // å¦‚æœæœ¬åœ°æ–‡ä»¶å·²ç»å­˜åœ¨ï¼Œä¸”ä¸å…è®¸è¦†ç›–çš„æ—¶å€™ï¼Œè¿½åŠ æ–°çš„å†…å®¹åˆ°æ–‡ä»¶æœ«å°¾
                        //   const oldCnt = await this.app.vault.read(originalFile)
                        //   if (oldCnt !== contents) {
                        //     await this.app.vault.append(originalFile, '\n' + contents)
                        //   }
                        // }
                        yield this.app.vault.modify(originalFile, contents);
                    }
                }
                catch (e) {
                    logger([`WuCai Official plugin: error writing ${processedFileName}:`, e]);
                    this.notice(`WuCai: error while writing ${processedFileName}: ${e}`, true, 4, true);
                    if (noteId) {
                        this.settings.notesToRefresh.push(noteId);
                        yield this.saveSettings();
                    }
                }
            }
            let isCompleted = false;
            if (isPartsDownloadLogic) {
                // å½“å‰æ˜¯æŒ‡å®šç¬”è®°è¿›è¡ŒåŒæ­¥ï¼Œæ‰€ä»¥æ¯æ¬¡å°±ä»£è¡¨æ˜¯ä¸€ç»„åŒæ­¥å®Œæˆ
                isCompleted = true;
            }
            else {
                // è®¡ç®—åŒæ­¥åçš„ä½ç½®
                // åœ¨åŒæ­¥çš„è¿‡ç¨‹ä¸­ä¸æ–­çš„æ›´æ–°åŒæ­¥ä½ç½®
                // ä¸æ˜¯å®šå‘åŒæ­¥æ—¶ï¼Œè®°å½•åŒæ­¥ä½ç½®
                let notesLastCursor = data2['data'].lastCursor;
                let tmpCursor = this.getNewLastCursor(notesLastCursor, lastCursor);
                if (tmpCursor) {
                    this.settings.lastCursor = tmpCursor;
                    // å½“å‰æ˜¯é€šè¿‡åç§»é‡èŒƒå›´è¿›è¡ŒåŒæ­¥
                    isCompleted = entriesCount <= 0;
                }
                else {
                    // å› ä¸ºæŸç§åŸå› å¯¼è‡´çš„å®šä½ä¸å‡†ï¼Œç»“æŸåŒæ­¥
                    isCompleted = true;
                }
            }
            yield this.saveSettings();
            // close the ZipReader
            // await zipReader.close()
            if (isCompleted) {
                yield this.acknowledgeSyncCompleted(buttonContext);
                this.handleSyncSuccess(buttonContext, 'Synced!', this.settings.lastCursor);
                this.notice('WuCai sync completed', true, 1, true);
                // @ts-ignore
                if (obsidian.Platform.isMobileApp) {
                    this.notice("If you don't see all of your WuCai files reload obsidian app", true);
                }
            }
            else if (BGCONSTS.IS_DEBUG) {
                yield this.acknowledgeSyncCompleted(buttonContext);
                this.handleSyncSuccess(buttonContext, 'Synced! debug mode', this.settings.lastCursor);
                this.notice('WuCai sync completed, in debug mode', true, 1, true);
            }
            else if (!BGCONSTS.IS_DEBUG) {
                this.handleSyncSuccess(buttonContext, 'syncing', this.settings.lastCursor);
                // this.notice('WuCai is syncing, ' + exportID, true, 1, true)
                yield new Promise((resolve) => setTimeout(resolve, 5000));
                this.downloadArchive(this.settings.lastCursor, [], buttonContext, isOverwrite);
            }
        });
    }
    acknowledgeSyncCompleted(buttonContext) {
        return __awaiter(this, void 0, void 0, function* () {
            let rsp;
            let url = '/apix/openapi/wucai/sync/ack';
            try {
                let params = { lastCursor: this.settings.lastCursor };
                rsp = yield this.callApi(url, params);
            }
            catch (e) {
                logger(['WuCai Official plugin: fetch failed to acknowledged sync: ', e]);
            }
            if (rsp && !rsp.ok) {
                logger(['WuCai Official plugin: bad response in acknowledge sync: ', rsp]);
                this.handleSyncError(buttonContext, this.getErrorMessageFromResponse(rsp));
            }
        });
    }
    configureSchedule() {
        return __awaiter(this, void 0, void 0, function* () {
            const minutes = parseInt(this.settings.frequency);
            let milliseconds = minutes * 60 * 1000; // minutes * seconds * milliseconds
            logger(['WuCai Official plugin: setting interval to ', minutes, 'minutes']);
            window.clearInterval(this.scheduleInterval);
            this.scheduleInterval = null;
            if (!milliseconds) {
                // we got manual option
                return;
            }
            this.scheduleInterval = window.setInterval(() => this.exportInit(null, true, 'schedule init'), milliseconds);
            this.registerInterval(this.scheduleInterval);
        });
    }
    refreshNoteExport() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.settings.refreshNotes) {
                return;
            }
            let noteIds = this.settings.notesToRefresh || [];
            if (noteIds.length <= 0) {
                return;
            }
            let newNoteIds = [];
            for (let i = 0; i < noteIds.length; i++) {
                newNoteIds.push(parseInt(noteIds[i]));
                if (i >= 5) {
                    break;
                }
            }
            this.downloadArchive(null, newNoteIds, null, true, 'refresh');
            this.settings.notesToRefresh = this.settings.notesToRefresh.filter((n) => !newNoteIds.includes(parseInt(n)));
        });
    }
    addNoteToRefresh(noteId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings.notesToRefresh.push(noteId);
            yield this.saveSettings();
        });
    }
    reimportFile(vault, fileName, isOverwrite = false) {
        const noteId = this.settings.notesPathIdsMap[fileName];
        if (!noteId) {
            this.notice('Failed to reimport. note id not found', true);
            return;
        }
        this.downloadArchive(null, [parseInt(noteId)], null, isOverwrite);
    }
    startSync() {
        logger(['started sync', this.settings.isSyncing]);
        if (this.settings.isSyncing) {
            this.notice('WuCai sync already in progress', true);
        }
        else {
            this.settings.isSyncing = true;
            this.saveSettings();
            this.exportInit(null, false, 'startSync init');
        }
    }
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore
            if (!obsidian.Platform.isMobileApp) {
                this.statusBar = new StatusBar(this.addStatusBarItem());
                this.registerInterval(window.setInterval(() => this.statusBar.display(), 1000));
            }
            yield this.loadSettings();
            this.registerEvent(this.app.vault.on('delete', (file) => __awaiter(this, void 0, void 0, function* () {
                // å°†åˆ é™¤çš„æ–‡ä»¶æ”¾åˆ°å¾…æ›´æ–°åˆ—è¡¨ï¼Œè¿™æ ·ä¸‹æ¬¡å°±å¯ä»¥é‡æ–°åŒæ­¥åˆ é™¤çš„é—®é¢˜
                const noteID = this.settings.notesPathIdsMap[file.path];
                if (noteID) {
                    yield this.addNoteToRefresh(noteID);
                }
                delete this.settings.notesPathIdsMap[file.path];
                delete this.settings.notesIdsPathMap[noteID];
                this.saveSettings();
                if (noteID) {
                    this.refreshNoteExport();
                }
            })));
            this.registerEvent(this.app.vault.on('rename', (file, oldPath) => {
                // å¦‚æœæ˜¯äº”å½©åˆ’çº¿ç›®å½•é‡Œçš„æ–‡ä»¶ï¼Œåœ¨é‡å‘½åçš„æ—¶å€™ï¼Œè¿›è¡Œå…³è”ï¼Œä»¥ä¿è¯ä¸‹æ¬¡åŒæ­¥èƒ½æ‰¾åˆ°ç›¸åº”çš„æ–‡ä»¶
                if (!oldPath.startsWith(this.settings.wuCaiDir + '/')) {
                    return;
                }
                logger(['rename path', file, oldPath]);
                const noteID = this.settings.notesPathIdsMap[oldPath];
                if (!noteID) {
                    // æ£€æµ‹æ˜¯å¦æ˜¯ä¿®æ”¹çš„ç›®å½•ï¼Œå¦‚æœæ˜¯ç›®å½•ï¼Œåˆ™éœ€è¦æ›´æ–°ç›®å½•ä¸‹çš„æ‰€æœ‰æ˜ å°„å…³ç³»
                    let oldPathLength = oldPath.length;
                    for (let tmpNoteId in this.settings.notesIdsPathMap) {
                        let note = this.settings.notesIdsPathMap[tmpNoteId];
                        if (!note || note == undefined) {
                            continue;
                        }
                        let tmpOldPath = note.path;
                        if (tmpOldPath.startsWith(oldPath + '/')) {
                            // æ›´æ–°æ­¤æ–‡ä»¶å¤¹ä¸‹é¢çš„æ–‡ä»¶æ˜ å°„å…³ç³»
                            let tmpNewPath = file.path + tmpOldPath.substring(oldPathLength);
                            logger(['rename map, ', oldPath, tmpOldPath, tmpNewPath]);
                            delete this.settings.notesPathIdsMap[tmpOldPath];
                            this.settings.notesPathIdsMap[tmpNewPath] = tmpNoteId;
                            this.settings.notesIdsPathMap[tmpNoteId].path = tmpNewPath;
                        }
                    }
                    return;
                }
                this.settings.notesPathIdsMap[file.path] = noteID;
                this.settings.notesIdsPathMap[noteID].path = file.path;
                delete this.settings.notesPathIdsMap[oldPath];
                this.saveSettings();
            }));
            this.addCommand({
                id: 'sync',
                name: 'Sync your data now',
                callback: () => {
                    this.startSync();
                },
            });
            // this.addCommand({
            //   id: 'wucai-official-format',
            //   name: 'Customize formatting',
            //   callback: () => window.open(`${baseURL}/export/obsidian/preferences`),
            // })
            this.addCommand({
                id: 'reimport',
                name: 'Delete and reimport this document',
                editorCheckCallback: (checking, editor, view) => {
                    const activeFilePath = view.file.path;
                    const isRWfile = activeFilePath in this.settings.notesPathIdsMap;
                    if (checking) {
                        return isRWfile;
                    }
                    if (this.settings.reimportShowConfirmation) {
                        const modal = new obsidian.Modal(view.app);
                        modal.contentEl.createEl('p', {
                            text: 'Warning: Proceeding will delete this file entirely (including any changes you made) ' +
                                'and then reimport a new copy of your highlights from WuCai.',
                        });
                        const buttonsContainer = modal.contentEl.createEl('div', { cls: 'wc-modal-btns' });
                        const cancelBtn = buttonsContainer.createEl('button', { text: 'Cancel' });
                        const confirmBtn = buttonsContainer.createEl('button', { text: 'Proceed', cls: 'mod-warning' });
                        const showConfContainer = modal.contentEl.createEl('div', { cls: 'wc-modal-confirmation' });
                        showConfContainer.createEl('label', { attr: { for: 'wc-ask-nl' }, text: "on't ask me in the future" });
                        const showConf = showConfContainer.createEl('input', { type: 'checkbox', attr: { name: 'wc-ask-nl' } });
                        showConf.addEventListener('change', (ev) => {
                            // @ts-ignore
                            this.settings.reimportShowConfirmation = !ev.target.checked;
                            this.saveSettings();
                        });
                        cancelBtn.onClickEvent(() => {
                            modal.close();
                        });
                        confirmBtn.onClickEvent(() => {
                            this.reimportFile(view.app.vault, activeFilePath, true);
                            modal.close();
                        });
                        modal.open();
                    }
                    else {
                        this.reimportFile(view.app.vault, activeFilePath, true);
                    }
                },
            });
            // this.registerMarkdownPostProcessor((el, ctx) => {
            //   if (!ctx.sourcePath.startsWith(this.settings.wuCaiDir)) {
            //     return
            //   }
            //   let matches: string[]
            //   try {
            //     // @ts-ignore
            //     matches = [...ctx.getSectionInfo(el).text.matchAll(/__(.+)__/g)].map((a) => a[1])
            //   } catch (TypeError) {
            //     // failed interaction with a Dataview element
            //     return
            //   }
            //   const hypers = el.findAll('strong').filter((e) => matches.contains(e.textContent))
            //   hypers.forEach((strongEl) => {
            //     const replacement = el.createEl('span')
            //     while (strongEl.firstChild) {
            //       replacement.appendChild(strongEl.firstChild)
            //     }
            //     replacement.addClass('wc-hyper-highlight')
            //     strongEl.replaceWith(replacement)
            //   })
            // })
            this.addSettingTab(new WuCaiSettingTab(this.app, this));
            yield this.configureSchedule();
            this.settings.isSyncing = false;
            if (this.settings.token && this.settings.triggerOnLoad && !this.settings.isSyncing) {
                // å› ä¸ºåŠ è½½å…³ç³»ï¼Œå¦‚æœç›®å½•æ²¡æœ‰åˆ›å»ºï¼Œå¯èƒ½æ˜¯obè¿˜æ²¡æœ‰å¯åŠ¨å®Œæˆ
                const dirInfo = this.app.vault.getAbstractFileByPath(this.settings.wuCaiDir);
                const noteDirNotExists = !dirInfo || !(dirInfo instanceof obsidian.TFolder);
                if (noteDirNotExists) {
                    this.app.workspace.onLayoutReady(() => {
                        // https://forum.obsidian.md/t/plugins-with-a-lot-to-do-at-startup-being-async-onlayoutready/26205
                        logger(['onload last cursor 1', this.settings.lastCursor]);
                        this.exportInit(null, true, 'onload + not exists');
                    });
                }
                else {
                    yield this.refreshNoteExport();
                    logger(['onload last cursor 2', this.settings.lastCursor]);
                    yield this.exportInit(null, true, 'onload + exists');
                }
            }
        });
    }
    onunload() {
        // æš‚æ—¶æ²¡æœ‰é€»è¾‘éœ€è¦å¤„ç†
        return;
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
    getObsidianClientID() {
        let tmpId = window.localStorage.getItem('wc-ObsidianClientId');
        if (tmpId) {
            return tmpId;
        }
        tmpId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        window.localStorage.setItem('wc-ObsidianClientId', tmpId);
        return tmpId;
    }
    getUserAuthToken(button, attempt = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            let uuid = this.getObsidianClientID();
            if (attempt === 0) {
                window.open(`${baseURL}/page/gentoken/${BGCONSTS.SERVICE_ID}/${uuid}`);
            }
            let response;
            try {
                let url = '/page/auth/openapi/gettoken';
                response = yield this.callApi(url, { did: uuid });
            }
            catch (e) {
                logger(['WuCai Official plugin: fetch failed in getUserAuthToken: ', e]);
            }
            if (!response || !response.ok) {
                logger(['WuCai Official plugin: bad response in getUserAuthToken: ', response]);
                this.showInfoStatus(button.parentElement, 'Authorization failed. Try again', 'wc-error');
                return;
            }
            let data2 = yield response.json();
            let data;
            data = data2['data'];
            if (1 === data2.code && data.accessToken) {
                this.settings.token = data.accessToken;
            }
            else {
                if (attempt > 20) {
                    logger('WuCai Official plugin: reached attempt limit in getUserAuthToken');
                    return;
                }
                logger(`WuCai Official plugin: didn't get token data, retrying (attempt ${attempt + 1})`);
                yield new Promise((resolve) => setTimeout(resolve, 1000));
                yield this.getUserAuthToken(button, attempt + 1);
            }
            yield this.saveSettings();
            return true;
        });
    }
}
class WuCaiSettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    display() {
        let { containerEl } = this;
        containerEl.empty();
        containerEl.createEl('h1', { text: 'WuCai Highlights Official' });
        containerEl
            .createEl('p', { text: 'Created by ' })
            .createEl('a', { text: 'å¸Œæœå£³äº”å½©', href: 'https://www.dotalk.cn/product/wucai' });
        containerEl.getElementsByTagName('p')[0].appendText(' ğŸš€ğŸš€');
        containerEl.createEl('h2', { text: 'Settings' });
        let token = this.plugin.settings.token;
        if (token && token.length > 0) {
            new obsidian.Setting(containerEl)
                .setName('Sync your WuCai data with Obsidian')
                .setDesc('On first sync, the WuCai plugin will create a new folder containing all your highlights')
                .setClass('wc-setting-sync')
                .addButton((button) => {
                button
                    .setCta()
                    .setTooltip('Once the sync begins, you can close this plugin page')
                    .setButtonText('Initiate Sync')
                    .onClick(() => __awaiter(this, void 0, void 0, function* () {
                    if (this.plugin.settings.isSyncing) {
                        // NOTE: This is used to prevent multiple syncs at the same time. However, if a previous sync fails,
                        //  it can stop new syncs from happening. Make sure to set isSyncing to false
                        //  if there's ever errors/failures in previous sync attempts, so that
                        //  we don't block syncing subsequent times.
                        new obsidian.Notice('WuCai sync already in progress');
                    }
                    else {
                        this.plugin.clearInfoStatus(containerEl);
                        this.plugin.settings.isSyncing = true;
                        yield this.plugin.saveData(this.plugin.settings);
                        button.setButtonText('Syncing...');
                        yield this.plugin.exportInit(button);
                    }
                }));
            });
            let el = containerEl.createEl('div', { cls: 'wc-info-container' });
            containerEl.find('.wc-setting-sync > .setting-item-control ').prepend(el);
            new obsidian.Setting(containerEl)
                .setName('Customize formatting options')
                .setDesc('You can customize which items export to Obsidian and how they appear from the WuCai website')
                .addButton((button) => {
                button.setButtonText('Customize').onClick(() => {
                    window.open(`${baseURL}/page/plugins/obsidian/preferences`);
                });
            });
            new obsidian.Setting(containerEl)
                .setName('Customize base folder')
                .setDesc('By default, the plugin will save all your highlights into a folder named WuCai')
                .addText((text) => text
                .setPlaceholder('Defaults to: WuCai')
                .setValue(this.plugin.settings.wuCaiDir)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.wuCaiDir = obsidian.normalizePath(value || 'WuCai');
                yield this.plugin.saveSettings();
            })));
            new obsidian.Setting(containerEl)
                .setName('Configure resync frequency')
                .setDesc('If not set to Manual, WuCai will automatically resync with Obsidian when the app is open at the specified interval')
                .addDropdown((dropdown) => {
                dropdown.addOption('0', 'Manual');
                dropdown.addOption('60', 'Every 1 hour');
                dropdown.addOption((12 * 60).toString(), 'Every 12 hours');
                dropdown.addOption((24 * 60).toString(), 'Every 24 hours');
                // select the currently-saved option
                dropdown.setValue(this.plugin.settings.frequency);
                dropdown.onChange((newValue) => {
                    // update the plugin settings
                    this.plugin.settings.frequency = newValue;
                    this.plugin.saveSettings();
                    // destroy & re-create the scheduled task
                    this.plugin.configureSchedule();
                });
            });
            new obsidian.Setting(containerEl)
                .setName('Sync automatically when Obsidian opens')
                .setDesc('If enabled, WuCai will automatically resync with Obsidian each time you open the app')
                .addToggle((toggle) => {
                toggle.setValue(this.plugin.settings.triggerOnLoad);
                toggle.onChange((val) => {
                    this.plugin.settings.triggerOnLoad = val;
                    this.plugin.saveSettings();
                });
            });
            new obsidian.Setting(containerEl)
                .setName('Resync deleted files')
                .setDesc('If enabled, you can refresh individual items by deleting the file in Obsidian and initiating a resync')
                .addToggle((toggle) => {
                toggle.setValue(this.plugin.settings.refreshNotes);
                toggle.onChange((val) => __awaiter(this, void 0, void 0, function* () {
                    this.plugin.settings.refreshNotes = val;
                    yield this.plugin.saveSettings();
                    if (val) {
                        this.plugin.refreshNoteExport();
                    }
                }));
            });
            if (this.plugin.settings.lastSyncFailed) {
                this.plugin.showInfoStatus(containerEl.find('.wc-setting-sync .wc-info-container').parentElement, 'Last sync failed', 'wc-error');
            }
        }
        else {
            // æ²¡æœ‰é…ç½® token çš„æƒ…å†µ
            new obsidian.Setting(containerEl)
                .setName('Connect Obsidian to WuCai')
                .setClass('wc-setting-connect')
                .setDesc('The WuCai plugin enables automatic syncing of all your highlights . Note: Requires WuCai account.')
                .addButton((button) => {
                button
                    .setButtonText('Connect')
                    .setCta()
                    .onClick((evt) => __awaiter(this, void 0, void 0, function* () {
                    const success = yield this.plugin.getUserAuthToken(evt.target);
                    if (success) {
                        this.display();
                    }
                }));
            });
            let el = containerEl.createEl('div', { cls: 'wc-info-container' });
            containerEl.find('.wc-setting-connect > .setting-item-control ').prepend(el);
        }
        const help = containerEl.createEl('p');
        help.innerHTML = "Question? Please see our <a href='https://www.dotalk.cn/s/M7'>feedback</a> ğŸ™‚";
    }
}

module.exports = WuCaiPlugin;
